/** * $Id: JFinalProperties.java,v 1.0 2019-07-14 00:46 chenmin Exp $ */package com.dbmeta.starter.config;import com.google.common.collect.Lists;import com.google.common.collect.Maps;import com.hthjsj.AnalysisConfig;import com.hthjsj.web.AppConst;import com.jfinal.kit.Prop;import com.jfinal.plugin.activerecord.dialect.Dialect;import com.jfinal.render.ViewType;import lombok.Data;import lombok.experimental.Accessors;import lombok.extern.slf4j.Slf4j;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.util.ObjectUtils;import org.springframework.validation.annotation.Validated;import javax.validation.constraints.NotBlank;import java.util.List;import java.util.Map;/** * @author 陈敏 * @version $Id: JFinalProperties.java,v 1.1 2019-07-14 00:46 chenmin Exp $ * Created on 2019-07-14 00:46 * My blog： https://www.chenmin.info */@Slf4j@Data@Validated@Accessors(chain = true)@ConfigurationProperties(prefix = "jfinal")public class JFinalProperties extends Prop {    public static final String DB_META_LOADED = "db-meta.loaded";    /**     * SQL模板路径     */    private List<String> sqlTemplates = Lists.newArrayList();    /**     * kit类全路径     */    private List<String> kitClasses = Lists.newArrayList();    /**     * 是否打开开发模式     */    private Boolean devMode = false;    /**     * 是否显示查询SQL     */    private Boolean showSql;    /**     * 数据库方言:默认支持MYSQL,ORACLE,SQLSERVER,SQLITE,POSTGRESQL     */    private Class<? extends Dialect> dialect;    private Boolean injectDependency = false;    private String baseUploadPath;    private String baseDownloadPath;    private Integer maxPostSize;    private Integer delayInSeconds;    private String defaultBaseName;    private String defaultLocale;    private Boolean injectSuperClass;    private Boolean reportAfterInvocation;    private String datePattern;    private String urlParaSeparator;    private String viewExtension;    private ViewType viewType;    private Boolean clearAfterMapping;    private Boolean mappingSuperClass;    private Boolean createSession;    private String baseTemplatePath;    private Boolean sessionInView;    /**     * 是否允许覆盖Request     */    private Boolean allowRequestOverride;    /**     * 是否允许覆盖Session     */    private Boolean allowSessionOverride;    /**     * 事务级别     */    private Integer transactionLevel;    /**     * 插件加载顺序     */    private Integer configPluginOrder;    /**     * 编码, 默认为: UTF-8     */    private String encoding;    /**     * 启用cglib代理，默认true     */    private Boolean enableCglibProxy = true; // 启用cglib代理，以便更好的兼容jfinal 和 springboot    /**     * Error View映射     */    private Map<Integer, String> errorViewMapping = Maps.newLinkedHashMap();    /**     * jfinal定制任务配置     */    private Map<String, TaskInfo> taskInfoMap = Maps.newLinkedHashMap();    private DbMeta dbMeta;    @Data    @Accessors(chain = true)    public static class TaskInfo {        /**         * 时间表达式         */        @NotBlank        private String cron;        /**         * 任务类         */        @NotBlank        private String task;        /**         * 是否开启守护进程         */        private Boolean daemon;        /**         * 是否开启任务,默认开启         */        private Boolean enable = true;        public TaskInfo() {        }        public TaskInfo(String cron, String task, boolean daemon, boolean enable) {            if (ObjectUtils.isEmpty(cron)) {                throw new IllegalArgumentException("cron 不能为空.");            }            if (ObjectUtils.isEmpty(task)) {                throw new IllegalArgumentException("task 不能为 null.");            }            this.cron = cron.trim();            this.task = task;            this.daemon = daemon;            this.enable = enable;        }    }    /**     * Servlet Api过滤地址。例如，设为: /db-meta/*,  则JFinal只会拦截处理匹配的接口。其余的都默认交给Spring处理。     * 注意: 如果你设置了此值，那么务必设置jfinal.db-meta.api-prefix， 并且保证apiPrefix为filterPrefix子集。     * 否则db-meta中内置的接口可能都将无法被JFinalFilter拦截，导致Spring报错接口404。     * 默认为: /* ，即拦截所有接口。此时SpringBoot接口必须扩展 {@link com.dbmeta.starter.config.ExtConfig} 将SpringBoot接口排除JFinal Handler     * example: /db-meta/*     */    private String filterPrefix;    @Data    public static class DbMeta {        private Boolean configAllowReplace;        private Boolean componentAllowReplace;        private Boolean userLogin;        private Boolean userAuth;        private String uploadDir;        /**         * db-meta路由接口前缀，此值会为db-meta所有内置接口地址添加此前缀。         */        private String apiPrefix;        private String mainJdbcUrl;        private String mainJdbcUsername;        private String mainJdbcPassword;        private String bizDb;        private Map<String, BizDb> bizDbConfig;        @Data        public static class BizDb {            private String jdbcUrl;            private String jdbcUsername;            private String jdbcPassword;        }        public void setApiPrefix(String apiPrefix) {            this.apiPrefix = apiPrefix;        }    }    public void initProp() {        try {            if (this.dbMeta == null) {                log.warn("spring配置文件中无db-meta配置项，将遵循db-meta默认配置文件加载规则");                return;            }            if (super.getBoolean(DB_META_LOADED, false)) {                // 防止重复加载                return;            }            super.properties.setProperty(DB_META_LOADED, "true");            super.properties.setProperty("devMode", toStr(this.devMode, "false"));            super.properties.setProperty(AppConst.CONFIG_ALLOW_REPLACE, toStr(this.dbMeta.configAllowReplace, "true"));            super.properties.setProperty(AppConst.UPLOAD_DIR, toStr(this.dbMeta.uploadDir, "/opt/www/db-meta-serve"));            super.properties.setProperty(AppConst.NEED_LOGIN, toStr(this.dbMeta.userLogin, "true"));            super.properties.setProperty(AppConst.NEED_AUTH, toStr(this.dbMeta.userAuth, "true"));            super.properties.setProperty(AppConst.ROUTER_PREFIX, toStr(this.dbMeta.apiPrefix, ""));            super.properties.setProperty(AppConst.COMPONENT_ALLOW_REPLACE, toStr(this.dbMeta.componentAllowReplace, "true"));            super.properties.setProperty(AnalysisConfig.SHOW_SQL, toStr(this.showSql, "false"));            super.properties.setProperty(AnalysisConfig.DB_MAIN_URL, toStr(this.dbMeta.mainJdbcUrl));            super.properties.setProperty(AnalysisConfig.DB_MAIN_USERNAME, toStr(this.dbMeta.mainJdbcUsername, "root"));            super.properties.setProperty(AnalysisConfig.DB_MAIN_PASSWORD, toStr(this.dbMeta.mainJdbcPassword));            super.properties.setProperty(AnalysisConfig.PREFIX_BIZ_DB, toStr(this.dbMeta.bizDb));            if (this.dbMeta.getBizDbConfig() != null && !this.dbMeta.getBizDbConfig().isEmpty()) {                for (String bizDbName : this.dbMeta.getBizDbConfig().keySet()) {                    DbMeta.BizDb bizDb = this.dbMeta.getBizDbConfig().get(bizDbName);                    super.properties.setProperty(bizDbName + AnalysisConfig.SUFFIX_BIZ_URL, toStr(bizDb.getJdbcUrl()));                    super.properties.setProperty(bizDbName + AnalysisConfig.SUFFIX_BIZ_USERNAME, toStr(bizDb.getJdbcUsername(), "root"));                    super.properties.setProperty(bizDbName + AnalysisConfig.SUFFIX_BIZ_PASSWORD, toStr(bizDb.getJdbcPassword()));                }            }        } catch (Exception e) {            log.error("spring配置文件中关于db-meta的配置项配置有误， 请检查！");            e.printStackTrace();        }    }    private String toStr(Object value) {        return toStr(value, "");    }    private String toStr(Object value, String defaultValue) {        if (value == null) {            return defaultValue;        }        return String.valueOf(value).trim();    }    public boolean hasDbMetaConfig() {        return this.dbMeta != null;    }}