# 功能计划

- [x] 完成内置的RBAC模块 
- [x] 提供部分内置页面: 登录页、错误页(401、403、500)
- [x] 提供默认的用户头像&下拉菜单(个人信息、登出)
- [ ] 提供数据源维护(dbmeta从配置文件获取数据源，改为从数据库中获取数据源)，从而在平台维护下，提供数据源维护模块。以便动态添加数据源
- [ ] 提供数据库自升级功能;
- [ ] 借助element-ui主题提供2~3个主题换肤;
- [ ] 提供多对多关联数据维护(涉及三张表)的功能模板;
- [ ] 首次启动引导, 提供界面进行初始化配置。类似于halo那样;

## 评估多机构支持————单体下玩多租户?
必须能够保留非机构模式！
### 单个数据库, orgId隔离
缺点: 对已有代码侵入比较大。

### 多个数据库, 库隔离
优点: dbMeta天然支持多数据源。
缺点: dbMeta的多数据源支持为的是业务上能够连接多个数据库。如果借助这个特性实现类似多租户的话, 那么单个租户实例就不能支持多数据源了!
    业务开发时, 如果用的数据库交互是非activerecord, 比如用mybatis, 那么数据库隔离需要自行做(借助动态数据源, 参考tenant-sdk-db-separate)
    

首先，dbMeta主机构下添加机构，并初始化机构数据库 ———— 可提供界面操作

- 初始化机构时, 应当可以支持勾选其开通的功能。例如: 勾选指定开通的模块(可能体现为菜单), 其对应的初始化脚本是不一样的。
- 问题是, 该机构用户登录后能使用的模块, 必须能控制在为其开通的那几个指定模块下。因此, 对于机构实例:
- 1. ROOT角色该不该存在? 如果不该存在, 或者即使存在，也不被"特殊对待"(实际实施应当双重保障)的话, 那么即使是我方的实施人员, 也无法利用
     dbMeta的高效特性进行在线升级、调整系统了。 但是如果保留ROOT角色设定, 那么企业用户就可能自我添加ROOT角色，从而绕开功能模块使用限制。
     因此问题的关键在于不允许用户自我绑定ROOT角色。
     
     【解决思路】: 固定ROOT用户和ROOT角色为系统特殊的用户和角色(后期可通过配置文件配置), 内置的ROOT用户不允许绑定角色, 内置的ROOT角色不允许绑定权限。
     【结论】 ROOT角色依然保留, 但机构实例角色表中无ROOT角色, 且不允许用户添加ROOT角色。但系统对ROOT的"特殊照顾"依旧保留。
- 2. 元数据维护能不能有? 我认为机构初始化脚本里是不能有元数据维护相关模块权限数据的。但是借助主机构ROOT能直接跳入机构实例的机制，
     在机构实例中进行元数据维护依然是可行的！

登录入口添加机构选择, 确定用户所连接的机构数据库, 机构标识需要附带到请求header中, 和token一样。

dbMeta后端数据库连接都必须依据机构id, 然后明确选择连接的机构数据库。因此:

- 所有机构数据库连接信息都必须缓存内存中
- 数据源切换操作必须方便快捷

开发思路:
- [ ] 1.新增meta_db表, 将数据源由配置文件改为数据库维护。
- [ ] 2.新增meta_org表, 并关联meta_db, 1:1关系。并提供meta_db和meta_org表的维护界面, 权限配置好。
- [ ] 3.改造DbMeta
  -[ ] 3.1 在认证、鉴权拦截器外围再添加一个机构拦截器, 确定请求所属机构, 并在ThreadLocal维护。
  -[ ] 3.2 所有数据库交互的地方都依据ThreadLocal中的orgId确定交互的数据库
  -[ ] 3.3 提供机构实例初始化逻辑, 并准备初始化脚本。初始化脚本需要根据界面选择开通的功能来生成不同的insert数据！表结构脚本是固定的。ROOT用户和ROOT角色的id都固定0。
  -[ ] 3.4 登录认证改造: 登录界面添加机构选择组件; 所有请求header应当携带orgId(除了登录界面的选择机构接口), 无orgId一律错误
- [ ] 4.提供配置项: 用以确定dbMeta运行实例为 机构模式/单例模式
- [ ] 5.调试

